# Partial List of Security Framework Bugs #

* `SecSignTransformCreate`, `SecVerifyTransformCreate`: Sign and verify transforms with a NULL `key` hang forever. (rdar://10394846)

* `SecSignTransformCreate`: The sign computation transformation created by `SecSignTransformCreate` does not report an error when the application does not have the credentials to sign data with the supplied `SecKeyRef`.  Instead, it runs successfully, but produces corrupt signature data of length 32768. The contents of this signature look like random memory junk. `SecVerifyTransform` confirms that these signatures are invalid. (rdar://10394759)

* `SecKeyGetBlockSize` does not have an availability tag. It was introduced in Mac OS X version 10.6. (rdar://10617706)

* `SecKeyGetBlockSize` returns the logical key size in bits, not the block size in bytes. (rdar://10623794)

* `SecKeyGenerateSymmetric` with `kSecAttrKeyType3DES` creates a key whose `kSecAttrKeyType` is not `kSecAttrKeyType3DES`, but "17", which corresponds to `CSSM_ALGID_3DES_3KEY_EDE`. (rdar://10617623)

* `kSecAttrApplicationTag` is documented as having `CFDataRef` values, but `SecItemCopyMatching` returns `CFStringRef`s. (rdar://10618031)

* `SecKeyGeneratePair` crashes with the following backtrace when it is given a string `kSecAttrApplicationTag` value. It works when the value is a `CFDataRef`.  (rdar://10618031)

        #0	0x00007fff8ff06590 in longcopy ()
        #1	0x00007fff8fef1f8f in memmove$VARIANT$sse3x ()
        #2	0x00007fff8b26712f in Security::CssmDbAttributeData::set(cssm_db_attribute_info const&, Security::CssmPolyData const&, Security::Allocator&) ()
        #3	0x00007fff8b3ae6a2 in Security::CssmAutoDbRecordAttributeData::add(cssm_db_attribute_info const&, Security::CssmPolyData const&) ()
        #4	0x00007fff8b2e8469 in Security::KeychainCore::ItemImpl::modifyAttributesAndData(SecKeychainAttributeList const*, unsigned int, void const*) ()
        #5	0x00007fff8b306f80 in SecKeychainItemModifyAttributesAndData ()
        #6	0x00007fff8b300aef in SetKeyLabelAndTag(OpaqueSecKeyRef*, void const*, __CFData const*) ()
        #7	0x00007fff8b30207f in SecKeyGeneratePair ()

* On the other hand, `SecKeyGenerateSymmetric` expects a `CFStringRef` for `kSecAttrApplicationTag` and fails with `paramErr` when given a `CFDataRef`. (rdar://10618031)
  
* `SecItemUpdate` can't set the `kSecAttrApplicationTag` attribute. It sets `kSecAttrLabel` instead. (It calls `SecKeychainItemModifyContent`, not `SecKeychainItemModifyAttributesAndData`.) (rdar://10618031)


* * *

* `SecKeyGenerateSymmetric` cannot be called twice in rapid succession to generate persistent keys without an application tag; it returns `errSecDuplicateItem`, even if the keys have different types and key sizes.

* `SecItemAdd` can't handle `CFDataRef` values for `kSecAttrApplicationTag`.

* `SecItemUpdate` can't update the `kSecAttrApplicationLabel` attribute. (It calls `SecKeychainItemModifyContent`, not `SecKeychainItemModifyAttributesAndData`.)

* `SecKeyGeneratePair` can only create permanent keys, even though the documentation states that setting `kSecAttrIsPermanent` to false should create a floating key. The function doesn't even look at `kSecAttrIsPermanent`.

* `kSecAttrIsExtractable` should be public, and implemented not just by `SecKeyGeneratePair`, but also `SecKeyGenerateSymmetric`.

* `SecKeyGenerateSymmetric` (when called with keychain = NULL) generates keys that I cannot add to a keychain. 
* `SecKeychainItemCreateCopy` can't copy a floating symmetric key generated by `SecKeyGenerate`/`SecKeyGenerateSymmetric` to a keychain (Function or operation not implemented. (-4))
* `SecItemAdd` doesn't like floating keys generated by `SecGenerate`/`SecKeyGenerateSymmetric`; it fails with `errSecInvalidKeyRef`. It works fine with floating keys generated by `SecKeyCreateFromData`.

* `SecKeyGenerateSymmetric` creates non-extractable keys. This isn't configurable. If `SecKeyGenerateSymmetric` is used without a keychain, the resulting `SecKey` is almost useless: you can't get to its data, but you also can't add it to a keychain later. You can encrypt and decrypt data with it, but since you cannot permanently store the key anywhere, there is very little point. (The latter is because floating keys have no kSecAttrApplicationLabel.) I'd prefer if extractability would be configurable by making `kSecAttrIsExtractable` public and adding support for it in `SecKeyGenerateSymmetric`.  Alternatively, the generated key should be made extractable when it's not generated into a keychain.


* `kSecAttrApplicationLabel`'s documentation is misleading/wrong: "Application label attribute key. The corresponding value is of type `CFStringRef` and contains a label for this item. This attribute is different from the `kSecAttrLabel` attribute, which is intended to be human-readable. This attribute is used to look up a key programmatically; in particular, for keys of class `kSecAttrKeyClassPublic` and `kSecAttrKeyClassPrivate`, the value of this attribute is the hash of the public key." Since the corresponding value's type is `CFStringRef`, it is impossible to store a hash of the public key in this attribute, or retrieve an attribute that stores a hash. We need better guidance on what to put here.  Especially since `SecPKCS12Import` refers to the same attribute as `kSecImportItemKeyID`, with a `CFDataRef` value!

* `SecKeyCreateFromData` should accept `kSecUseKeychain` and `kSecAttrAccess` keys and a key for specifying the format of the data.

* `SecItemImport` creates non-extractable keys. This isn't configurable.

* `SecItemImport` and `SecKeychainItemImport` don't return the imported key; they return some floating key instead.

* `SecItemDelete` succeeds, but doesn't actually delete keys if more than one application has access to them. This isn't documented. It is quite unacceptable that an API doesn't do its purpose, but still returns success.

* `SecCertificateCopyNormalizedSubjectContent` does not include the outer SEQUENCE tag, while `SecCertificateCopyNormalizedIssuerContent` does. This causes problems with `SecItemCopyMatching` (when searching for a particular `kSecAttrSubject`), which expects a full DN including the topmost SEQUENCE.  The documentation for `SecCertificateCopyNormalizedSubjectContent` states that "The subject is a sequence in the format used by `SecItemCopyMatching`", which is thus incorrect.

* From the Security Transforms Programming Guide: "The security transforms API supports only symmetric encryption and decryption. For asymmetric encryption and decryption, you must use a lower-level API, such as CDSA." CDSA is deprecated in Mac OS X Lion. Given that the private key may not be extractable from the keychain, I think it is reasonable to expect an officially blessed `SecKeyRef` API to decrypt/encrypt data asymmetrically.


