{\rtf1\ansi\ansicpg1252\cocoartf1138\cocoasubrtf230
{\fonttbl\f0\fnil\fcharset0 Menlo-Bold;\f1\fnil\fcharset0 Menlo-Regular;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww15200\viewh8400\viewkind0
\deftab560
\pard\tx560\pardeftab560\pardirnatural

\f0\b\fs26 \cf0 \CocoaLigature0 SecSignTransformCreate, SecVerifyTransformCreate
\f1\b0 : Sign and verify transforms with key=NULL hang forever. rdar://10394846\
\

\f0\b SecSignTransformCreate
\f1\b0 : The sign computation transformation created by SecSignTransformCreate does not report an error when the application does not have the credentials to sign data with the supplied SecKeyRef.  Instead, it runs successfully, but produces corrupt signature data of length 32768. The contents of this signature look like random memory junk. SecVerifyTransform confirms that these signatures are invalid. rdar://10394759\
\
From the 
\f0\b Security Transforms
\f1\b0  Programming Guide: "The security transforms API supports only symmetric encryption and decryption. For asymmetric encryption and decryption, you must use a lower-level API, such as CDSA." CDSA is deprecated in Mac OS X Lion. Given that the private key may not be extractable from the keychain, I think it is reasonable to expect an officially blessed SecKeyRef API to decrypt/encrypt data asymmetrically.\
\
\pard\pardeftab720\sa120

\f0\b \cf0 \CocoaLigature1 kSecAttrApplicationLabel
\f1\b0 's documentation is misleading/wrong.\
\pard\tx560\pardeftab560\pardirnatural
\cf0 \CocoaLigature0 \
SecItem.h: kSecAttrApplicationLabel \
\
\pard\pardeftab720\li1120
\cf0 \CocoaLigature1 kSecAttrApplicationLabel\
\pard\pardeftab720\li1120\sa120
\cf0 Application label attribute key.\
The corresponding value is of type CFStringRef and contains a label for this item. This attribute is different from the kSecAttrLabel attribute, which is intended to be human-readable. This attribute is used to look up a key programmatically; in particular, for keys of class kSecAttrKeyClassPublic and kSecAttrKeyClassPrivate, the value of this attribute is the hash of the public key.\
Available in Mac OS X v10.6 and later.\
Declared in SecItem.h.\
\pard\pardeftab720\sa120
\cf0 \
Since the corresponding value's type is CFStringRef, it is impossible to store a hash of the public key in this attribute, or retrieve an attribute that stores a hash. We need better guidance on what to put here.  Especially since 
\f0\b SecPKCS12Import
\f1\b0  refers to the same attribute as kSecImportItemKeyID, with a CFDataRef value!!!!\
\
\pard\tx560\pardeftab560\pardirnatural

\f0\b \cf0 \CocoaLigature0 SecKeyGenerateSymmetric
\f1\b0  creates non-extractable keys. This isn't configurable. If SecKeyGenerateSymmetric is used without a keychain, the resulting SecKey is almost useless: you can't get to its data, but you also can't add it to a keychain later. (The latter is because floating keys are generated without a kSecAttrApplicationLabel.)\
\

\f0\b SecKeyGenerateSymmetric
\f1\b0  (when called with keychain = NULL) generates keys that I cannot add to a keychain.\
\

\f0\b SecKeyGenerateSymmetric
\f1\b0  with kSecAttrKeyType3DES creates a key whose kSecAttrKeyType is not kSecAttrKeyType3DES, but "17", which corresponds to CSSM_ALGID_3DES_3KEY_EDE.\
\

\f0\b SecKeyGeneratePair
\f1\b0  can only create permanent keys. The documentation tells otherwise. The function doesn't look at kSecAttrIsPermanent, but it does handle the private kSecAttrIsExtractable, which would be nice if documented.\
\

\f0\b SecKeyGeneratePair
\f1\b0  crashes with the following backtrace when it is given a string kSecAttrApplicationTag value. It works when the value is a CFDataRef. kSecAttrApplicationTag is documented as having string values, and SecItemCopyMatching returns it as such.\
\
#0	0x00007fff8ff06590 in longcopy ()\
#1	0x00007fff8fef1f8f in memmove$VARIANT$sse3x ()\
#2	0x00007fff8b26712f in Security::CssmDbAttributeData::set(cssm_db_attribute_info const&, Security::CssmPolyData const&, Security::Allocator&) ()\
#3	0x00007fff8b3ae6a2 in Security::CssmAutoDbRecordAttributeData::add(cssm_db_attribute_info const&, Security::CssmPolyData const&) ()\
#4	0x00007fff8b2e8469 in Security::KeychainCore::ItemImpl::modifyAttributesAndData(SecKeychainAttributeList const*, unsigned int, void const*) ()\
#5	0x00007fff8b306f80 in SecKeychainItemModifyAttributesAndData ()\
#6	0x00007fff8b300aef in SetKeyLabelAndTag(OpaqueSecKeyRef*, void const*, __CFData const*) ()\
#7	0x00007fff8b30207f in SecKeyGeneratePair ()\
\
\

\f0\b SecKeyCreateFromData
\f1\b0  should accept kSecUseKeychain and kSecAttrAccess keys and a key for specifying the format of the data.\
\

\f0\b SecItemUpdate
\f1\b0  can't update the kSecAttrApplicationLabel attribute. (It calls SecKeychainItemModifyContent, not SecKeychainItemModifyAttributesAndData.)\
\

\f0\b SecItemUpdate
\f1\b0  can't set the kSecAttrApplicationTag attribute. It sets kSecAttrLabel instead. (It calls SecKeychainItemModifyContent, not SecKeychainItemModifyAttributesAndData.)\
\

\f0\b SecItemImport
\f1\b0  creates non-extractable keys. This isn't configurable.\
\

\f0\b SecItemImport
\f1\b0  and 
\f0\b SecKeychainItemImport
\f1\b0  don't return the imported key; they return some floating key instead.\
\

\f0\b SecKeychainItemCreateCopy
\f1\b0  can't copy a floating symmetric key generated by SecKeyGenerate[Symmetric] to a keychain (Function or operation not implemented. (-4))\
\

\f0\b SecItemAdd
\f1\b0  doesn't like floating keys generated by SecGenerate[Symmetric]; it fails with errSecInvalidKeyRef. It works fine with floating keys generated by SecKeyCreateFromData.\
\

\f0\b SecItemDelete
\f1\b0  succeeds, but doesn't actually delete keys if more than one application has access to them. This isn't documented. It is quite unacceptable that an API doesn't do its purpose, but still returns success.\
}